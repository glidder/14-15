\begin{lstlisting}

bool comparePair(const std::pair <std::pair<int, int>, float>& a, const std::pair <std::pair<int, int>, float>& b) {
  return a.second > b.second;
}

bool is_sorted (values_t::iterator first, values_t::iterator last)
{
  if (first==last) return true;
  values_t::iterator next = first;
  while (++next!=last) {
    if (comparePair(*next,*first))
      return false;
    ++first;
  }
  return true;
}
/***/
#ifdef PRUEBAS_CAJA_NEGRA
	for(int i=0;i<10;++i) {
		cellVal.push_back(std::make_pair(std::make_pair((float)i,(float)i),(float)i));
	}
	std::sort(cellVal.begin(),cellVal.end(),comparePair);
	while( next_permutation(cellVal.begin(),cellVal.end(),comparePair)){
		values_t copiacellVal=mergeSort(cellVal);
		if(!is_sorted(copiacellVal.begin(),copiacellVal.end())){
			std::cout<< "ERROR EN LA ORDENACION POR FUSION <<std::endl;
		}
	}
	std::sort(cellVal.begin(),cellVal.end(),comparePair);
	while( next_permutation(cellVal.begin(),cellVal.end(),comparePair)){
		values_t copiacellVal=quickSort(cellVal);
		if(!is_sorted(copiacellVal.begin(),copiacellVal.end())){
			std::cout<< "ERROR EN LA ORDENACION RAPIDA" <<std::endl;		
		}
	}
#endif
\end{lstlisting}
